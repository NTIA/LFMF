/** @file Airy.cpp
 * Implements the model from ITS.Propagation.LFMF.
 */

#include "LFMF.h"

#include <cmath>    // for abs, cos, exp, pow, sin, sqrt
#include <complex>  // for std::arg, std::complex

namespace ITS {
namespace Propagation {
namespace LFMF {

/******************************************************************************
 *
 *  Description:  This routine finds the Airy, Bariy, Wi(1) and Wi(2) 
 *                functions and their derivatives for a complex input argument
 *                from a shifted Taylor series or by asymptotic approximation 
 *                depending of the location of the input argument.
 *
 *                This routine determines the so-called "Airy Functions of the 
 *                third kind" Wi(1) and Wi(2) that are found in equation 38 
 *                of NTIA Report 87-219 "A General Theory of Radio 
 *                Propagation through a Stratified Atmosphere", George 
 *                Hufford, July 1987
 *
 *                The Airy function that appeared in the original GWINT and 
 *                GWRES had the switches all mangled from what George Hufford
 *                had in mind this routine has the corrected switches. Please
 *                see the Airy function code that appears in the appendix of
 *                OT/ITS RR 11 "A Wave Hop Propagation Program for an 
 *                Anisotropic Ionosphere" L. A. Berry and J. E. Herman 
 *                April 1971
 *
 *  @param[in]    Z             - Input argument
 *  @param[in]    kind          - Switch that indicates what type of Airy function to solve for
 *  @param[in]    scaling       - Type of scaling to use
 *
 *  @return       Ai            - The desired Airy function calculated at Z
 *
 *         Note:  A note on scaling the output from this program
 *
 *                There is a definitional problem with the Airy function 
 *                which is inevitable relative to how it was defined in the 
 *                original LFMF code originated with the Hufford's AIRY 
 *                subroutine.
 *
 *                Using the scaling equal to HUFFORD in this program follows
 *                the definitions of Wi(1) and Wi(2) as defined by Hufford 
 *                (87-219)
 *
 *                Using the scaling equal to WAIT in this program uses the 
 *                definitions of W1 and W2 defined in Deminco (99-368) and 
 *                in the original LFMF code following Berry via Wait.
 *
 *                The two solutions differ by a constant. As Hufford notes 
 *                concerning Wi(1) and Wi(2) in 87-219
 *
 *                "Except for multiplicative constants they correspond to 
 *                what Fock (1965) calls w1 and w2 and to what Wait (1962) 
 *                calls w2 and w1"
 *
 *                The following are the multiplicative constants that allow 
 *                for the translation between Hufford Wi(2) and Wi(1) with 
 *                Wait W1 and W2, respectively. These are given here as a 
 *                reference if this function is used for programs other 
 *                than LFMF.
 *
 *                // Wait
 *                complex<double> WW2  = complex<double>(     sqrt(3.0*PI),      sqrt(PI));
 *                complex<double> WDW2 = complex<double>(-1.0*sqrt(3.0*PI),      sqrt(PI));
 *                complex<double> WW1  = complex<double>(     sqrt(3.0*PI), -1.0*sqrt(PI));
 *                complex<double> WDW1 = complex<double>(-1.0*sqrt(3.0*PI), -1.0*sqrt(PI));
 *
 *                // Hufford
 *                complex<double> HW2  = 2.0*complex<double>(cos( PI/3.0), sin( PI/3.0));
 *                complex<double> HDW2 = 2.0*complex<double>(cos(-PI/3.0), sin(-PI/3.0));
 *                complex<double> HW1  = 2.0*complex<double>(cos(-PI/3.0), sin(-PI/3.0));
 *                complex<double> HDW1 = 2.0*complex<double>(cos( PI/3.0), sin( PI/3.0));
 *
 *                // (Multiplicative constant) * Huffords Wi'(1) = Wait W1'
 *                // So the multiplicative constants are:
 *                complex<double> uDW2 = WDW2/HDW1; // uDW2 = complex<double>(0.0,  sqrt(PI))
 *                complex<double> uW2  = WW2/HW1;   // uW2  = complex<double>(0.0,  sqrt(PI))
 *                complex<double> uDW1 = WDW1/HDW2; // uDW1 = complex<double>(0.0, -sqrt(PI))
 *                complex<double> uW1  = WW1/HW2;   // uW1  = complex<double>(0.0, -sqrt(PI))
 *
 *                To make the solutions that are generated by this program 
 *                for the Hufford Airy functions of the "3rd kind" abundantly
 *                clear please examine the following examples.
 *
 *                For Z = 8.0 + 8.0 i the Asymptotic Solution is used
 *
 *                Ai( 8.0 + 8.0 i) =  6.576933e-007 +  9.312331e-006 i
 *                Ai'(8.0 + 8.0 i) =  9.79016e-006  + -2.992170e-005 i
 *                Bi( 8.0 + 8.0 i) = -1.605154e+003 + -4.807200e+003 i
 *                Bi'(8.0 + 8.0 i) =  1301.23 + -16956 i
 *                Wi(1)(8.0 + 8.0 i) = -4.807200e+003 +  1.605154e+003 i
 *                Wi(2)(8.0 + 8.0 i) =  4.807200e+003 + -1.605154e+003 i
 *                Ai(z) - j*Bi(z) = -4.807200e+003 +  1.605154e+003 i
 *                Ai(z) + j*Bi(z) =  4.807200e+003 + -1.605154e+003 i
 *
 *                For Z = 1.0 - 2.0 i the Taylor series with a shifted
 *                center of expansion solution used.
 *
 *                Ai( 1.0 - 2.0 i) = -2.193862e-001 + 1.753859e-001 i
 *                Ai'(1.0 - 2.0 i) =  0.170445 + -0.387622 i
 *                Bi( 1.0 - 2.0 i) =  4.882205e-002 + -1.332740e-001 i
 *                Bi'(1.0 - 2.0 i) = -0.857239 + -0.495506 i
 *                Wi(1)(1.0 - 2.0 i) = -3.526603e-001 + 1.265638e-001 i
 *                Wi(2)(1.0 - 2.0 i) = -8.611221e-002 + 2.242079e-001 i
 *                Ai(z) - j*Bi(z) = -3.526603e-001 + 1.265639e-001 i
 *                Ai(z) + j*Bi(z) = -8.611221e-002 + 2.242080e-001 i
 *
 *****************************************************************************/
std::complex<double> Airy(
    std::complex<double> Z, AiryFunctionKind kind, AiryFunctionScaling scaling
) {
    // NQTT, ASLT data
    int NQTT[15] = {
        1, 3, 7, 12, 17, 23, 29, 35, 41, 47, 53, 59, 64, 68, 71
    };  // Centers of Expansion of Taylor series on real axis indices into the
    // AV, APV, BV and BPV arrays
    int N;  // Index into NQTT[] array
    int NQ8;  // Index that indicates the radius of convergence of the Taylor series solution
    int CoERealidx;  // Center of Expansion of the Taylor Series real index
    int CoEImagidx;  // Center of Expansion of the Taylor Series imaginary index
    int cnt;         // loop counter for the Taylor series calculation
    int derivative;  // index for derivative

    bool
        reflection;  // Flag to indicate that the answer needs to be flipped over since this routine only finds solutions in quadrant 1 and 2

    std::complex<double> A[2], ZT, B0, B1, B2, B3, AN, U, ZA, ZB, ZU;  // Temps
    std::complex<double> CoE;  // Center of Expansion of the Taylor series
    std::complex<double>
        Ai;  // Ai is either Ai(at the center of expansion of the Taylor series) or Bi( at the center of expansion of the Taylor series )
    std::complex<double> Aip;   // Aip is the derivative of the above
    std::complex<double> sum1;  // Temp Sum for the asymptotic solution
    std::complex<double> sum2;  // Temp Sum for the asymptotic solution
    std::complex<double> ZB2, ZB1;

    double
        one;  // Used in the calculation of the asymptotic solution is either -1 or 1

    // terms for asymptotic series.  second column is for derivative
    constexpr int SIZE_OF_ASV = 15;
    constexpr double ASV[SIZE_OF_ASV][2]
        = {{0.5989251E+5, -0.6133571E+5},
           {0.9207207E+4, -0.9446355E+4},
           {0.1533169E+4, -0.1576357E+4},
           {0.2784651E+3, -0.2870332E+3},
           {0.5562279E+2, -0.5750830E+2},
           {0.1234157E+2, -0.1280729E+2},
           {0.3079453E+1, -0.3210494E+1},
           {0.8776670E+0, -0.9204800E+0},
           {0.2915914E+0, -0.3082538E+0},
           {0.1160991E+0, -0.1241059E+0},
           {0.5764919E-1, -0.6266216E-1},
           {0.3799306E-1, -0.4246283E-1},
           {0.3713349E-1, -0.4388503E-1},
           {0.6944444E-1, -0.9722222E-1},
           {0.1000000E+1, 0.1000000E+1}};

    //////////////////////////////////////////////////////////////////////////
    // Initialize the center of expansion arrays.                           //
    //////////////////////////////////////////////////////////////////////////
    // The array AV[] (and BV[]) is the Airy function for Ai(a) to shift    //
    // the Taylor series from the origin to the point a Thus the series is  //
    // f(z -a)                                                              //
    // Why George Hufford choose these particular locations for the         //
    // of the centers of expansion is unknown. The centers of expansion are //
    // included here to remove any ambiguity in the method.                 //
    //////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////   Center of expansion
    ///////////////////////////////////////////////////   ( Real, Imaginary)

    // Complex array of the value Ai(a) Airy function
    // where a is the complex location of the center of expansion of the Taylor series
    constexpr std::complex<double> AV[] = {
        {-3.2914520e-001, +0.0000000e+000},  //   (-6,0)
        {-2.6780040e+000, +1.4774590e+000},  //   (-6,1/sin(pi/3))
        {+3.5076100e-001, +0.0000000e+000},  //   (-5,0)
        {+2.4122260e+000, +6.9865120e-001},  //   (-5,1/sin(pi/3))
        {+3.3635530e+001, -3.4600960e+000},  //   (-5,2/sin(pi/3))
        {+3.4449740e+002, -3.3690890e+002},  //   (-5,3/sin(pi/3))
        {-7.0265530e-002, +0.0000000e+000},  //   (-4,0)
        {-5.4818220e-001, -1.9207370e+000},  //   (-4,1/sin(pi/3))
        {-1.3383400e+001, -1.6022590e+001},  //   (-4,2/sin(pi/3))
        {-2.2967800e+002, -3.2072450e+001},  //   (-4,3/sin(pi/3))
        {-1.8040780e+003, +2.1917680e+003},  //   (-4,4/sin(pi/3))
        {-3.7881430e-001, +0.0000000e+000},  //   (-3,0)
        {-1.3491840e+000, +8.4969080e-001},  //   (-3,1/sin(pi/3))
        {-6.0453340e+000, +1.0623180e+001},  //   (-3,2/sin(pi/3))
        {+3.1169620e+001, +9.8813520e+001},  //   (-3,3/sin(pi/3))
        {+9.8925350e+002, +1.3905290e+002},  //   (-3,4/sin(pi/3))
        {+2.2740740e-001, +0.0000000e+000},  //   (-2,0)
        {+7.1857400e-001, +9.7809090e-001},  //   (-2,1/sin(pi/3))
        {+6.0621090e+000, +2.7203010e+000},  //   (-2,2/sin(pi/3))
        {+3.6307080e+001, -2.0961360e+001},  //   (-2,3/sin(pi/3))
        {-6.7139790e+001, -3.0904640e+002},  //   (-2,4/sin(pi/3))
        {-2.8001650e+003, +4.6649370e+002},  //   (-2,5/sin(pi/3))
        {+5.3556090e-001, +0.0000000e+000},  //   (-1,0)
        {+9.2407370e-001, -1.9106560e-001},  //   (-1,1/sin(pi/3))
        {+1.8716190e+000, -2.5743310e+000},  //   (-1,2/sin(pi/3))
        {-7.2188440e+000, -1.2924200e+001},  //   (-1,3/sin(pi/3))
        {-8.1787380e+001, +3.2087010e+001},  //   (-1,4/sin(pi/3))
        {+2.9933950e+002, +5.6922180e+002},  //   (-1,5/sin(pi/3))
        {+3.5502810e-001, +0.0000000e+000},  //   ( 0,0)
        {+3.1203440e-001, -3.8845390e-001},  //   ( 0,1/sin(pi/3))
        {-5.2840000e-001, -1.0976410e+000},  //   ( 0,2/sin(pi/3))
        {-4.2009350e+000, +1.1940150e+000},  //   ( 0,3/sin(pi/3))
        {+7.1858830e+000, +1.9600910e+001},  //   ( 0,4/sin(pi/3))
        {+1.0129120e+002, -7.5951230e+001},  //   ( 0,5/sin(pi/3))
        {+1.3529240e-001, +0.0000000e+000},  //   ( 1,0)
        {+3.2618480e-002, -1.7084870e-001},  //   ( 1,1/sin(pi/3))
        {-3.4215380e-001, -8.9067650e-002},  //   ( 1,2/sin(pi/3))
        {-1.4509640e-001, +1.0328020e+000},  //   ( 1,3/sin(pi/3))
        {+4.1001970e+000, -6.8936910e-001},  //   ( 1,4/sin(pi/3))
        {-1.3030120e+001, -1.6910540e+001},  //   ( 1,5/sin(pi/3))
        {+3.4924130e-002, +0.0000000e+000},  //   ( 2,0)
        {-8.4464730e-003, -4.2045150e-002},  //   ( 2,1/sin(pi/3))
        {-6.9313270e-002, +3.5364800e-002},  //   ( 2,2/sin(pi/3))
        {+1.5227620e-001, +1.2848450e-001},  //   ( 2,3/sin(pi/3))
        {+1.0681370e-001, -6.7766150e-001},  //   ( 2,4/sin(pi/3))
        {-2.6193430e+000, +1.5699860e+000},  //   ( 2,5/sin(pi/3))
        {+6.5911390e-003, +0.0000000e+000},  //   ( 3,0)
        {-3.9443990e-003, -6.8060110e-003},  //   ( 3,1/sin(pi/3))
        {-5.9820130e-003, +1.1799010e-002},  //   ( 3,2/sin(pi/3))
        {+2.9922500e-002, -5.9772930e-003},  //   ( 3,3/sin(pi/3))
        {-7.7464130e-002, -5.2292400e-002},  //   ( 3,4/sin(pi/3))
        {+1.1276590e-001, +3.5112440e-001},  //   ( 3,5/sin(pi/3))
        {+9.5156390e-004, +0.0000000e+000},  //   ( 4,0)
        {-8.0843000e-004, -7.6590130e-004},  //   ( 4,1/sin(pi/3))
        {+1.6147820e-004, +1.7661760e-003},  //   ( 4,2/sin(pi/3))
        {+2.0138720e-003, -3.1976720e-003},  //   ( 4,3/sin(pi/3))
        {-9.5086780e-003, +4.5377830e-003},  //   ( 4,4/sin(pi/3))
        {+3.7560190e-002, +5.7361920e-004},  //   ( 4,5/sin(pi/3))
        {+1.0834440e-004, +0.0000000e+000},  //   ( 5,0)
        {-1.0968610e-004, -5.9902330e-005},  //   ( 5,1/sin(pi/3))
        {+1.0778190e-004, +1.5771600e-004},  //   ( 5,2/sin(pi/3))
        {-6.8980940e-005, -3.7626460e-004},  //   ( 5,3/sin(pi/3))
        {-1.6166130e-004, +9.7457770e-004},  //   ( 5,4/sin(pi/3))
        {+9.9476940e-006, +0.0000000e+000},  //   ( 6,0)
        {-1.0956820e-005, -2.9508800e-006},  //   ( 6,1/sin(pi/3))
        {+1.4709070e-005, +8.1042090e-006},  //   ( 6,2/sin(pi/3))
        {-2.4446020e-005, -2.0638140e-005},  //   ( 6,3/sin(pi/3))
        {+7.4921290e-007, +0.0000000e+000},  //   ( 7,0)
        {-8.4619070e-007, -3.6807340e-008},  //   ( 7,1/sin(pi/3))
        {+1.2183960e-006, +8.3589200e-008}   //   ( 7,2/sin(pi/3))
    };
    //////////////////////////////////////////////////////////////////////////
    // This array APV[] is the derivative of the Airy function for Ai'(a)   //
    //////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////   Center of expansion
    ///////////////////////////////////////////////////   ( Real, Imaginary)
    // Complex array of the value Ai'(a) derivative of the Airy function
    // where a is the complex location of the center of expansion of the Taylor series
    // presumably for Ai'[z]
    constexpr std::complex<double> APV[] = {
        {+3.4593550e-001, +0.0000000e+000},  //  (-6,0)
        {+4.1708880e+000, +6.2414440e+000},  //  (-6,1/sin(pi/3))
        {+3.2719280e-001, +0.0000000e+000},  //  (-5,0)
        {+1.0828740e+000, -5.4928300e+000},  //  (-5,1/sin(pi/3))
        {-2.3363520e+001, -7.4901850e+001},  //  (-5,2/sin(pi/3))
        {-1.0264880e+003, -5.6707940e+002},  //  (-5,3/sin(pi/3))
        {-7.9062860e-001, +0.0000000e+000},  //  (-4,0)
        {-3.8085830e+000, +1.5129610e+000},  //  (-4,1/sin(pi/3))
        {-2.6086380e+001, +3.5540710e+001},  //  (-4,2/sin(pi/3))
        {+1.0761840e+002, +5.1239940e+002},  //  (-4,3/sin(pi/3))
        {+6.6597800e+003, +1.8096190e+003},  //  (-4,4/sin(pi/3))
        {+3.1458380e-001, +0.0000000e+000},  //  (-3,0)
        {+1.8715430e+000, +2.0544840e+000},  //  (-3,1/sin(pi/3))
        {+2.2591740e+001, +4.8563000e+000},  //  (-3,2/sin(pi/3))
        {+1.6163000e+002, -1.4335600e+002},  //  (-3,3/sin(pi/3))
        {-8.0047160e+002, -2.1527450e+003},  //  (-3,4/sin(pi/3))
        {+6.1825900e-001, +0.0000000e+000},  //  (-2,0)
        {+1.3019600e+000, -1.2290770e+000},  //  (-2,1/sin(pi/3))
        {+1.5036120e-001, -1.1008090e+001},  //  (-2,2/sin(pi/3))
        {-7.0116800e+001, -4.0480820e+001},  //  (-2,3/sin(pi/3))
        {-4.8317170e+002, +4.9692760e+002},  //  (-2,4/sin(pi/3))
        {+4.8970660e+003, +4.8627290e+003},  //  (-2,5/sin(pi/3))
        {-1.0160570e-002, +0.0000000e+000},  //  (-1,0)
        {-5.4826640e-001, -7.1365290e-001},  //  (-1,1/sin(pi/3))
        {-4.6749130e+000, -1.1924250e-001},  //  (-1,2/sin(pi/3))
        {-1.0536400e+001, +2.4943710e+001},  //  (-1,3/sin(pi/3))
        {+1.6333770e+002, +9.0394910e+001},  //  (-1,4/sin(pi/3))
        {+5.6449460e+002, -1.4248320e+003},  //  (-1,5/sin(pi/3))
        {-2.5881940e-001, +0.0000000e+000},  //  ( 0,0)
        {-4.8620750e-001, +1.5689920e-001},  //  ( 0,1/sin(pi/3))
        {-4.7348130e-001, +1.7093440e+000},  //  ( 0,2/sin(pi/3))
        {+7.0373840e+000, +3.6281820e+000},  //  ( 0,3/sin(pi/3))
        {+1.7739590e+001, -4.0360420e+001},  //  ( 0,4/sin(pi/3))
        {-2.9791510e+002, -3.8408890e+001},  //  ( 0,5/sin(pi/3))
        {-1.5914740e-001, +0.0000000e+000},  //  ( 1,0)
        {-1.1340420e-001, +1.9730500e-001},  //  ( 1,1/sin(pi/3))
        {+4.0126210e-001, +3.9223000e-001},  //  ( 1,2/sin(pi/3))
        {+1.3348650e+000, -1.4377270e+000},  //  ( 1,3/sin(pi/3))
        {-7.9022490e+000, -4.2063640e+000},  //  ( 1,4/sin(pi/3))
        {-1.3892750e+000, +5.1229420e+001},  //  ( 1,5/sin(pi/3))
        {-5.3090380e-002, +0.0000000e+000},  //  ( 2,0)
        {-1.6832970e-003, +6.8366970e-002},  //  ( 2,1/sin(pi/3))
        {+1.3789400e-001, -1.1613800e-002},  //  ( 2,2/sin(pi/3))
        {-1.4713730e-001, -3.7151990e-001},  //  ( 2,3/sin(pi/3))
        {-1.0070200e+000, +1.1591350e+000},  //  ( 2,4/sin(pi/3))
        {+7.5045050e+000, +4.6913120e-001},  //  ( 2,5/sin(pi/3))
        {-1.1912980e-002, +0.0000000e+000},  //  ( 3,0)
        {+5.1468570e-003, +1.3660890e-002},  //  ( 3,1/sin(pi/3))
        {+1.8309710e-002, -1.8808590e-002},  //  ( 3,2/sin(pi/3))
        {-6.4461590e-002, -1.3611790e-002},  //  ( 3,3/sin(pi/3))
        {+1.0516240e-001, +1.9313050e-001},  //  ( 3,4/sin(pi/3))
        {+2.0520050e-001, -9.1772620e-001},  //  ( 3,5/sin(pi/3))
        {-1.9586410e-003, +0.0000000e+000},  //  ( 4,0)
        {+1.4695650e-003, +1.8086380e-003},  //  ( 4,1/sin(pi/3))
        {+5.9709950e-004, -3.8332700e-003},  //  ( 4,2/sin(pi/3))
        {-6.8910890e-003, +5.4467430e-003},  //  ( 4,3/sin(pi/3))
        {+2.6167930e-002, -8.4092000e-004},  //  ( 4,4/sin(pi/3))
        {-8.8284470e-002, -4.6475310e-002},  //  ( 4,5/sin(pi/3))
        {-2.4741390e-004, +0.0000000e+000},  //  ( 5,0)
        {+2.3707840e-004, +1.6461110e-004},  //  ( 5,1/sin(pi/3))
        {-1.7465570e-004, -4.2026780e-004},  //  ( 5,2/sin(pi/3))
        {-1.0394520e-004, +9.4761840e-004},  //  ( 5,3/sin(pi/3))
        {+1.3004110e-003, -2.2446660e-003},  //  ( 5,4/sin(pi/3))
        {-2.4765200e-005, +0.0000000e+000},  //  ( 6,0)
        {+2.6714870e-005, +9.8691570e-006},  //  ( 6,1/sin(pi/3))
        {-3.3539770e-005, -2.7113280e-005},  //  ( 6,2/sin(pi/3))
        {+4.9197840e-005, +6.9349090e-005},  //  ( 6,3/sin(pi/3))
        {-2.0081510e-006, +0.0000000e+000},  //  ( 7,0)
        {+2.2671240e-006, +2.7848510e-007},  //  ( 7,1/sin(pi/3))
        {-3.2692130e-006, -7.3943490e-007},  //  ( 7,2/sin(pi/3))
    };

    /////////////////////////////////////////////////////////////////////////

    // Complex array of the value Bi(a) Airy function
    // where a is the complex location of the center of expansion of the Taylor series
    constexpr std::complex<double> BV[] = {
        {-1.466984e-001, -9.813078e-017},  // (-6,0)
        {-1.489391e+000, -2.660635e+000},  // (-6,1/sin(pi/3))
        {-1.383691e-001, +0.000000e+000},  // (-5,0)
        {-7.034482e-001, +2.384547e+000},  // (-5,1/sin(pi/3))
        {+3.460723e+000, +3.363363e+001},  // (-5,2/sin(pi/3))
        {+3.369090e+002, +3.444973e+002},  // (-5,3/sin(pi/3))
        {+3.922347e-001, -1.041605e-016},  // (-4,0)
        {+1.956219e+000, -5.327226e-001},  // (-4,1/sin(pi/3))
        {+1.602464e+001, -1.338050e+001},  // (-4,2/sin(pi/3))
        {+3.207239e+001, -2.296777e+002},  // (-4,3/sin(pi/3))
        {-2.191768e+003, -1.804078e+003},  // (-4,4/sin(pi/3))
        {-1.982896e-001, +4.440892e-016},  // (-3,0)
        {-8.880754e-001, -1.308713e+000},  // (-3,1/sin(pi/3))
        {-1.062975e+001, -6.044056e+000},  // (-3,2/sin(pi/3))
        {-9.881405e+001, +3.116914e+001},  // (-3,3/sin(pi/3))
        {-1.390528e+002, +9.892534e+002},  // (-3,4/sin(pi/3))
        {-4.123026e-001, +1.451806e-016},  // (-2,0)
        {-1.034766e+000, +6.541962e-001},  // (-2,1/sin(pi/3))
        {-2.720266e+000, +6.048328e+000},  // (-2,2/sin(pi/3))
        {+2.096300e+001, +3.630613e+001},  // (-2,3/sin(pi/3))
        {+3.090465e+002, -6.713963e+001},  // (-2,4/sin(pi/3))
        {-4.664937e+002, -2.800165e+003},  // (-2,5/sin(pi/3))
        {+1.039974e-001, +0.000000e+000},  // (-1,0)
        {+2.797458e-001, +8.086491e-001},  // (-1,1/sin(pi/3))
        {+2.606133e+000, +1.870297e+000},  // (-1,2/sin(pi/3))
        {+1.292648e+001, -7.213647e+000},  // (-1,3/sin(pi/3))
        {-3.208774e+001, -8.178697e+001},  // (-1,4/sin(pi/3))
        {-5.692218e+002, +2.993394e+002},  // (-1,5/sin(pi/3))
        {+6.149266e-001, +0.000000e+000},  // ( 0,0)
        {+6.732023e-001, +3.575876e-001},  // ( 0,1/sin(pi/3))
        {+1.125057e+000, -4.471292e-001},  // ( 0,2/sin(pi/3))
        {-1.211148e+000, -4.191469e+000},  // ( 0,3/sin(pi/3))
        {-1.960240e+001, +7.182663e+000},  // ( 0,4/sin(pi/3))
        {+7.595175e+001, +1.012911e+002},  // ( 0,5/sin(pi/3))
        {+1.207424e+000, +0.000000e+000},  // ( 1,0)
        {+5.951440e-001, +6.156664e-001},  // ( 1,1/sin(pi/3))
        {-1.002325e-001, -1.338228e-001},  // ( 1,2/sin(pi/3))
        {-1.089323e+000, -2.019524e-001},  // ( 1,3/sin(pi/3))
        {+7.047139e-001, +4.091592e+000},  // ( 1,4/sin(pi/3))
        {+1.691067e+001, -1.302705e+001},  // ( 1,5/sin(pi/3))
        {+3.298095e+000, +0.000000e+000},  // ( 2,0)
        {+2.244706e-001, +2.421124e+000},  // ( 2,1/sin(pi/3))
        {-1.199515e+000, -1.167656e-001},  // ( 2,2/sin(pi/3))
        {+6.781072e-003, -2.225418e-001},  // ( 2,3/sin(pi/3))
        {+7.470822e-001, +1.832986e-001},  // ( 2,4/sin(pi/3))
        {-1.590993e+000, -2.617694e+000},  // ( 2,5/sin(pi/3))
        {+1.403733e+001, +0.000000e+000},  // ( 3,0)
        {-3.731398e+000, +1.066394e+001},  // ( 3,1/sin(pi/3))
        {-4.440986e+000, -4.309647e+000},  // ( 3,2/sin(pi/3))
        {+2.373933e+000, -5.300179e-001},  // ( 3,3/sin(pi/3))
        {-2.821481e-001, +5.657373e-001},  // ( 3,4/sin(pi/3))
        {-3.904913e-001, -5.168316e-002},  // ( 3,5/sin(pi/3))
        {+8.384707e+001, +0.000000e+000},  // ( 4,0)
        {-4.356467e+001, +5.497027e+001},  // ( 4,1/sin(pi/3))
        {-7.156364e+000, -4.113550e+001},  // ( 4,2/sin(pi/3))
        {+1.455852e+001, +1.109071e+001},  // ( 4,3/sin(pi/3))
        {-6.111359e+000, -1.094609e-001},  // ( 4,4/sin(pi/3))
        {+1.403434e+000, -7.255043e-001},  // ( 4,5/sin(pi/3))
        {+6.577920e+002, +0.000000e+000},  // ( 5,0)
        {-4.598656e+002, +3.242259e+002},  // ( 5,1/sin(pi/3))
        {+1.324505e+002, -3.294705e+002},  // ( 5,2/sin(pi/3))
        {+2.057579e+001, +1.674034e+002},  // ( 5,3/sin(pi/3))
        {-3.161505e+001, -5.302141e+001},  // ( 5,4/sin(pi/3))
        {+6.536446e+003, +0.000000e+000},  // ( 6,0)
        {-5.316522e+003, +1.992175e+003},  // ( 6,1/sin(pi/3))
        {+2.888529e+003, -2.373473e+003},  // ( 6,2/sin(pi/3))
        {-1.078657e+003, +1.551931e+003},  // ( 6,3/sin(pi/3))
        {+8.032779e+004, +0.000000e+000},  // ( 7,0)
        {-7.001987e+004, +8.828416e+003},  // ( 7,1/sin(pi/3))
        {+4.676699e+004, -1.085924e+004}   // ( 7,2/sin(pi/3))
    };

    //////////////////////////////////////////////////////////////

    // Complex array of the value Bi'(a) derivative of the Airy function
    // where a is the complex location of the center of expansion of the Taylor series
    // presumably for Ai'[z]
    constexpr std::complex<double> BPV[] = {
        {-8.128988e-001, +3.365185e-016},  //    (-6,0)
        {-6.287609e+000, +4.146176e+000},  //    (-6,1/sin(pi/3))
        {+7.784118e-001, -3.004629e-016},  //    (-5,0)
        {+5.554036e+000, +1.063645e+000},  //    (-5,1/sin(pi/3))
        {+7.490659e+001, -2.336310e+001},  //    (-5,2/sin(pi/3))
        {+5.670796e+002, -1.026488e+003},  //    (-5,3/sin(pi/3))
        {-1.166706e-001, +2.371654e-015},  //    (-4,0)
        {-1.532413e+000, -3.730947e+000},  //    (-4,1/sin(pi/3))
        {-3.554558e+001, -2.608034e+001},  //    (-4,2/sin(pi/3))
        {-5.124001e+002, +1.076185e+002},  //    (-4,3/sin(pi/3))
        {-1.809619e+003, +6.659780e+003},  //    (-4,4/sin(pi/3))
        {-6.756112e-001, -2.403703e-017},  //    (-3,0)
        {-2.142202e+000, +1.818610e+000},  //    (-3,1/sin(pi/3))
        {-4.863137e+000, +2.258023e+001},  //    (-3,2/sin(pi/3))
        {+1.433564e+002, +1.616285e+002},  //    (-3,3/sin(pi/3))
        {+2.152746e+003, -8.004716e+002},  //    (-3,4/sin(pi/3))
        {+2.787952e-001, +0.000000e+000},  //    (-2,0)
        {+1.300360e+000, +1.185229e+000},  //    (-2,1/sin(pi/3))
        {+1.103082e+001, +1.397575e-001},  //    (-2,2/sin(pi/3))
        {+4.048422e+001, -7.011484e+001},  //    (-2,3/sin(pi/3))
        {-4.969277e+002, -4.831712e+002},  //    (-2,4/sin(pi/3))
        {-4.862729e+003, +4.897066e+003},  //    (-2,5/sin(pi/3))
        {+5.923756e-001, +0.000000e+000},  //    (-1,0)
        {+9.080502e-001, -5.080757e-001},  //    (-1,1/sin(pi/3))
        {+1.499485e-001, -4.631403e+000},  //    (-1,2/sin(pi/3))
        {-2.494926e+001, -1.052676e+001},  //    (-1,3/sin(pi/3))
        {-9.039663e+001, +1.633370e+002},  //    (-1,4/sin(pi/3))
        {+1.424833e+003, +5.644943e+002},  //    (-1,5/sin(pi/3))
        {+4.482884e-001, +0.000000e+000},  //    ( 0,0)
        {+2.493288e-002, -1.876446e-001},  //    ( 0,1/sin(pi/3))
        {-1.774795e+000, -3.533830e-001},  //    ( 0,2/sin(pi/3))
        {-3.663891e+000, +7.026174e+000},  //    ( 0,3/sin(pi/3))
        {+4.036322e+001, +1.773235e+001},  //    ( 0,4/sin(pi/3))
        {+3.840990e+001, -2.979143e+002},  //    ( 0,5/sin(pi/3))
        {+9.324359e-001, +0.000000e+000},  //    ( 1,0)
        {-1.293870e-001, +7.817697e-001},  //    ( 1,1/sin(pi/3))
        {-8.385825e-001, +4.901385e-001},  //    ( 1,2/sin(pi/3))
        {+1.421331e+000, +1.181168e+000},  //    ( 1,3/sin(pi/3))
        {+4.244380e+000, -7.895016e+000},  //    ( 1,4/sin(pi/3))
        {-5.123410e+001, -1.383387e+000},  //    ( 1,5/sin(pi/3))
        {+4.100682e+000, +0.000000e+000},  //    ( 2,0)
        {-9.576171e-001, +3.432468e+000},  //    ( 2,1/sin(pi/3))
        {-1.747487e+000, -8.602854e-001},  //    ( 2,2/sin(pi/3))
        {+9.978890e-001, -6.434913e-001},  //    ( 2,3/sin(pi/3))
        {-1.127841e+000, -7.762214e-001},  //    ( 2,4/sin(pi/3))
        {-5.136144e-001, +7.476880e+000},  //    ( 2,5/sin(pi/3))
        {+2.292221e+001, +0.000000e+000},  //    ( 3,0)
        {-1.021000e+001, +1.662556e+001},  //    ( 3,1/sin(pi/3))
        {-5.018884e+000, -1.067168e+001},  //    ( 3,2/sin(pi/3))
        {+5.067979e+000, +1.074279e+000},  //    ( 3,3/sin(pi/3))
        {-1.620678e+000, +1.029461e+000},  //    ( 3,4/sin(pi/3))
        {+1.055970e+000, -2.041230e-001},  //    ( 3,5/sin(pi/3))
        {+1.619267e+002, +0.000000e+000},  //    ( 4,0)
        {-1.021827e+002, +9.434616e+001},  //    ( 4,1/sin(pi/3))
        {+9.638391e+000, -8.764529e+001},  //    ( 4,2/sin(pi/3))
        {+2.157904e+001, +3.568852e+001},  //    ( 4,3/sin(pi/3))
        {-1.346647e+001, -6.665778e+000},  //    ( 4,4/sin(pi/3))
        {+4.276735e+000, -9.657825e-002},  //    ( 4,5/sin(pi/3))
        {+1.435819e+003, +0.000000e+000},  //    ( 5,0)
        {-1.099383e+003, +5.897525e+002},  //    ( 5,1/sin(pi/3))
        {+4.709887e+002, -6.717565e+002},  //    ( 5,2/sin(pi/3))
        {-7.965464e+001, +4.040825e+002},  //    ( 5,3/sin(pi/3))
        {-2.418965e+001, -1.582957e+002},  //    ( 5,4/sin(pi/3))
        {+1.572560e+004, +0.000000e+000},  //    ( 6,0)
        {-1.334470e+004, +3.525428e+003},  //    ( 6,1/sin(pi/3))
        {+8.229089e+003, -4.446372e+003},  //    ( 6,2/sin(pi/3))
        {-3.795705e+003, +3.141147e+003},  //    ( 6,3/sin(pi/3))
        {+2.095527e+005, +0.000000e+000},  //    ( 7,0)
        {-1.853403e+005, +7.452520e+003},  //    ( 7,1/sin(pi/3))
        {+1.286235e+005, -8.069218e+003}   //    ( 7,2/sin(pi/3))
    };

    ////////////////////////////////////////
    // Validate input - kind & derivative //
    ////////////////////////////////////////
    if ((kind != AIRY) && (kind != BAIRY) && (kind != WONE) && (kind != DWONE)
        && (kind != WTWO) && (kind != DWTWO)) {
        return std::complex<double>(0, 0);  // Airy Error: Invalid kind value
    };

    if ((scaling != NONE) && (scaling != HUFFORD) && (scaling != WAIT)) {
        return std::complex<double>(0, 0);  // Airy Error: Invalid scaling value
    };

    // Set the derivative flag
    if (kind == DWTWO || kind == DWONE || kind == AIRYD || kind == BAIRYD) {
        derivative = YES;
    } else {
        derivative = NO;
    };

    // Now do something productive with numbers...

    // In the original version of this by George Hufford it calculated Ai(Z), Ai'(Z) and the
    // Airy functions of the "3rd kind" Wi(1)(Z) and Wi(2)(Z) (see Eqn 38 in NTIA Report 87-219)
    // Note: Theta in 87-219 is Z in this program.
    // The input switch had three values, here we are going to have four so that the
    // Bairy function doesn't feel left out.

    // The following scales the input parameter Z depending on what the user is trying to do.
    // If the user is trying to find just the Ai(Z), Ai'(Z), Bi(Z) or Bi'(Z) there is no scaling.
    if (kind == AIRY || kind == BAIRY || kind == AIRYD || kind == BAIRYD) {
        // For Ai(Z) and  Bi(Z) No translation in the complex plane
        U = std::complex<double>(1.0, 0.0);
    }
    // Note that W1 Wait = Wi(2) Hufford and W2 Wait = Wi(1) Hufford
    // So the following inequalities keep this all straight
    else if (((kind == DWONE || kind == WONE) && scaling == HUFFORD)
             || ((kind == DWTWO || kind == WTWO) && scaling == WAIT)) {
        // This corresponds to Wi(1)(Z) in Eqn 38 Hufford NTIA Report 87-219
        // or Wait W2
        U = std::complex<double>(
            std::cos(2.0 * PI / 3.0), std::sin(2.0 * PI / 3.0)
        );
    } else if (((kind == DWTWO || kind == WTWO) && scaling == HUFFORD)
               || ((kind == DWONE || kind == WONE) && scaling == WAIT)) {
        // This corresponds to Wi(2)(Z) in Eqn 38 Hufford NTIA Report 87-219
        // or Wait W1
        U = std::complex<double>(
            std::cos(-2.0 * PI / 3.0), std::sin(-2.0 * PI / 3.0)
        );
    };

    // Translate the input parameter
    ZU = Z * U;

    // We will be only calculating for quadrant 1 and 2. If the desired value is in 3 or 4 we
    // will have to flip it over after the calculation
    reflection = false;
    if (ZU.imag() <= 0) {
        reflection
            = true;  // reflection = true means Z.imag() <= 0, use reflection formula to get result
        ZU = std::complex<double>(ZU.real(), -ZU.imag());
    };

    // Begin the calculation to determine if
    //          a) the shifted Taylor series will be used or
    //          b) the Asymptotic approximation is used.
    // A shifted Taylor series is necessary because the Taylor series is defined with a center of expansion
    // at the origin is a poor approximation to the true value of the (B)Airy function.

    // NOTE: The condition for which method is used is dependant on that value of Z and not the
    // transformed version of ZU, which is the shifted Z by exp(+-j*2*pi/3).
    // For the calculation of Ai(Z) and Bi(Z) Z is not shifted.
    // For the calculation of Wi(1)(Z) and Wi(2)(Z) the value of Ai(ZU) is found.

    // Initialize the indexes for the center of expansion
    // Note these are used in the if statements below as flags
    N = 0;
    NQ8 = 0;

    // If Z is small, use Taylor's series at various centers of expansion chosen by George Hufford
    // If Z is large, use Asymptotic series NIST DLMF 9.4.5 - 9.4.8

    // The following inequality is formed from the implicit arguments for the AV[], BV[], BPV[] and APV[]
    // The inequality makes sure that the center of expansion for the Taylor series solution is not
    // exceeded.
    //      (ZU.real() >= -6.5) -6.5 is 0.5 is the real value of the center of expansion in the array
    //      (ZU.real() <= 7.5)   7.5 is 0.5 is the real value of the center of expansion in the array
    //      (ZU.imag() <= 6.35) 6.35 is 5.5/sin(PI/3) which is 0.5 past 5/sin(PI/3)
    if ((ZU.real() >= -6.5) && (ZU.real() <= 7.5) && (ZU.imag() <= 6.35)) {
        // choose center of expansion of the Taylor series
        CoERealidx = (int)(ZU.real() + std::copysign(0.5, ZU.real()));
        CoEImagidx = (int)(std::sin(PI / 3.0) * (ZU.imag() + 0.5)
        );  // sin(60)*(Z.imag()+0.5)

        N = NQTT[CoERealidx + 6]
          + CoEImagidx;  // N is index of center of expansion

        // Check to see if N is out of bounds
        if (N
            >= 70) {  // Stop if the index N reaches the limit of array AV[] which is 70
            //printf("Airy() Error: Z is too large\n");
            return std::complex<double>(0, 0);
        };

        NQ8 = NQTT
            [CoERealidx
             + 7];  // The next real center of expansion or what is know here ...
                    // as the area of the Taylor's series

        // if Z is inside Taylor's series area, continue. Otherwise, go to asymptotic series
        if (N < NQ8) {
            ///////////////////////////////////////////
            // Compute the function by Taylor Series //
            ///////////////////////////////////////////

            // sum Taylor's series around nearest expansion point
            // The arrays AV[] and APV[] are incremented in the complex domain by 1/sin(PI/3)
            CoE = std::complex<double>(
                (double)CoERealidx, (double)CoEImagidx / std::sin(PI / 3.0)
            );

            // Translate the input parameter to the new location
            ZU = ZU - CoE;

            // Calculate the first term of the Taylor Series
            // To do this we need to find the Airy or Bairy function at the center of
            // expansion, CoE, that has been precalculated in the arrays above.
            if (kind == BAIRY || kind == BAIRYD) {
                Ai = BV[N - 1];    // Bi(CoE)
                Aip = BPV[N - 1];  // Bi'(CoE)
            } else {               // All other cases use the Coe for Ai(z)
                Ai = AV[N - 1];    // Ai(CoE)
                Aip = APV[N - 1];  // Ai'(CoE)
            };

            // Find the first elements of the Taylor series
            //                                                       Translation
            B1 = Ai;  // B1 is first term for function        Ai(a)
            B3 = B1 * CoE
               * ZU;     // B3 is second term for derivative     Ai(a)*a*(z-a)
            A[1] = Aip;  // A is first term for derivation       Ai'(a)
            B2 = A[1] * ZU;  // B2 is second term for function       Ai'(a)(z-a)
            A[0]
                = B2
                + B1;  // A[0] is the sum of Ai() or Bi()      Ai'(a)(z-a) + Ai(a)
            A[1]
                = A[1]
                + B3;  // A[1] is the sum of Ai'() or Bi'()    Ai'(a) + Ai(a)*a*(z-a)

            AN = 1.0;

            // Initialize the counter
            cnt = 0;

            // compute terms of series and sum until convergence
            do {
                do {
                    AN = AN + 1.0;
                    B3 = B3 * ZU / AN;
                    A[0] = B3 + A[0];
                    B0 = B1;
                    B1 = B2;
                    B2 = B3;
                    B3 = (CoE * B1 + ZU * B0) * ZU / AN;
                    A[1] = B3 + A[1];

                } while ((std::abs(B2) > (0.5E-7 * std::abs(A[0])))
                         || (std::abs(B3) > (0.5E-7 * std::abs(A[1])))
                );  // Has the convergence criteria been met?
                cnt++;

            } while (cnt < 3);  // require that the loop be executed 3 times
        }

    };  // if ((ZU.real() >= -6.5) && (ZU.real() <= 7.5) && (ZU.imag() <= 6.35))

    // Determine if the data for the center of expansion is exceeded
    if (((ZU.real() < -6.5) || (ZU.real() > 7.5) || (ZU.imag() > 6.35))
        || (N >= NQ8)
        //|| (Z.real() == 0.0 && Z.imag() == 0.0)) {    //Replaced with AlmostEqualRelative
        || (AlmostEqualRelative(Z.real(), 0.0)
            && AlmostEqualRelative(Z.imag(), 0.0))) {
        ///////////////////////////////////////////////
        // Compute the function by Asymptotic Series //
        ///////////////////////////////////////////////

        ///////////////////////////////////////////////////////
        // Please see                                        //
        // "On the Asymptotic Expansion of Airy's Integral"  //
        // E. T. Copson, Cambridge Press, November, 1962     //
        // for details on why a second series is necessary   //
        // The equations found in the reference above appear //
        // to be what Hufford used in the creation of this   //
        // algorithm                                         //
        ///////////////////////////////////////////////////////

        // Find intermediate values
        ZA = std::sqrt(ZU);          // zeta^(1/2)
        ZT = (2.0 / 3.0) * ZU * ZA;  // NIST DLMF 9.7.1 => -(2/3)zeta^(3/2)

        if (kind == BAIRY || kind == BAIRYD) {
            one = 1.0;  // Terms for the Bairy sum do not alternate sign
        } else {
            one = -1.0;  // All other functions use the Airy whose sum alternates sign
        }

        // Compute the asymptotic series either sum over k for (u_k*zeta^-k) or sum over k for (v_k*zeta^-k)
        // Which is used depends on M => M = 0 use u_k M = 1 use v_k
        // By doing this backward you don't have to do multiple powers zeta^-1
        // Note the coefficients are backward so the for loop will be forward
        sum1 = std::complex<double>(0.0, 0.0);  // Initialize the sum
        for (int i = 0; i < 14; i++) {
            sum1 = (std::pow(one, i) * ASV[i][derivative] + sum1) / ZT;
        };
        sum1 = ASV[SIZE_OF_ASV - 1][derivative]
             + sum1;  // Add the first element that is a function of zeta^0

        // Now determine if a second series is necessary
        // If it is not set the second sum to zero

        ////////////////////////////////////////////////////////////////////////////////////
        // Historic Note:
        // Hufford originally used the following inequality in AIRY()
        // (See OT/ITS RR 11) IF(XT(2) .GT. 0. .AND. XT(l) .LT. ll.8595) LG=4
        // to determine if a second series is required for a reasonable level of accuracy.
        // The C translation for the variables defined here
        // would be if(ZT.imag() <= 0.0) && (ZT.real() >= -ll.8595)
        // In the LFMF code the inequality for the same purpose is (translated to C)
        // if((ZT.imag() <= 0.0) && (ZT.real() >= -8.4056))
        // Since ZT = (2/3)ZU^(3/2) and for ZT.imag() = 0.0 and ZT.real() = -8.4056
        // ZU = -2.70859033 + j*4.69141606 which has an angle of 2*PI/3
        // Similarly for Hufford's original code
        // ZU = -3.40728475 + j*5.90159031 which has an angle of 2*PI/3
        // Thus we could replace the following with the inequality
        // if(ZU.arg() > 2.0*PI/3.0)
        //////////////////////////////////////////////////////////////////////////////////////

        // From Copson the F(z) solution is only valid for phase(z) <= PI/3.0
        // While the F(z) + i*G(z) solution is necessary for phase(z) > PI/3.0
        if (std::abs(std::arg(ZU)) > PI / 3.0) {
            sum2 = std::complex<double>(0.0, 0.0);  // Initialize the second sum
            for (int i = 0; i < 14; i++) {
                sum2 = (ASV[i][derivative] + sum2) / ZT;
            };
            sum2 = ASV[SIZE_OF_ASV - 1][derivative]
                 + sum2;  // Add the first element that is a function of zeta^0
        } else {          // Only one series is necessary for accuracy
            sum2 = std::complex<double>(0.0, 0.0);
        };

        // Now do the final function that leads the sum depending on what the user wants.
        // The leading function has to be taken apart so that it can be assembled as necessary for
        // the possible two parts of the sum
        if (kind == BAIRY || kind == BAIRYD) {
            if (derivative == NO) {
                ZB = 1.0 / (std::sqrt(ZA));  // NIST DLMF 9.7.8
            } else if (derivative == YES) {
                ZB = std::sqrt(ZA);  // NIST DLMF 9.7.7
            };
            ZB1 = ZB * std::exp(ZT)
                / std::sqrt(PI);  // For Bairy multiply by e^(zeta)/sqrt(PI)
            ZB2 = ZB * 1.0 / (std::exp(ZT) * std::sqrt(PI));

        } else {  // All other kind use Airy
            if (derivative == NO) {
                ZB = 1.0 / std::sqrt(ZA);  // NIST DLMF 9.7.6
            } else if (derivative == YES) {
                ZB = -1.0 * std::sqrt(ZA);  // NIST DLMF 9.7.5
            };
            ZB1 = ZB * 1.0
                / (2.0 * std::exp(ZT) * std::sqrt(PI)
                );  // For Airy multiply be e^(-zeta)/(2.0*sqrt(PI))
            ZB2 = ZB * std::exp(ZT) / (2.0 * std::sqrt(PI));
        };


        // Multiply by the leading coefficient to get the results for NIST DLMF 9.7.5 - 9.7.8
        if (derivative == YES) {
            A[derivative]
                = ZB1 * sum1 - std::complex<double>(0.0, 1.0) * ZB2 * sum2;
        } else if (derivative == NO) {
            A[derivative]
                = ZB1 * sum1 + std::complex<double>(0.0, 1.0) * ZB2 * sum2;
        };

    };  // if (( Z.real() < 6.5 || Z.real() > 7.5 || Z.imag() > 6.35 || N > NQ8 || ((Z.real() == 0 && Z.imag() == 0))))


    //////////////////////////////////////////////
    // End of the Asymptotic Series Calculation //
    //////////////////////////////////////////////

    // Store the desired quantity
    Ai = A[derivative];

    // Final Transform to get the desired function
    // Was the input parameter in quadrant 3 or 4?
    // If it was we have to take the conjugate of the calculation result
    if (reflection != false) {
        Ai = std::complex<double>(Ai.real(), -Ai.imag());
    };

    // The final scaling factor is a function of the kind, derivative and scaling flags
    if (scaling == NONE) {
        // The number from the Taylor series or asymptotic calculation
        // does not need to multiplied by anything
        U = std::complex<double>(1.0, 0.0);
    }
    // Hufford Wi(1) and Wi'(1)
    else if ((kind == WONE || kind == DWONE) && (scaling == HUFFORD)) {
        if (derivative == NO) {
            U = 2.0
              * std::complex<double>(std::cos(-PI / 3.0), std::sin(-PI / 3.0));
        } else if (derivative == YES) {
            U = 2.0
              * std::complex<double>(std::cos(PI / 3.0), std::sin(PI / 3.0));
        };
    }
    // Hufford Wi(2) and Wi'(2)
    else if ((kind == WTWO || kind == DWTWO) && (scaling == HUFFORD)) {
        if (derivative == NO) {
            U = 2.0
              * std::complex<double>(std::cos(PI / 3.0), std::sin(PI / 3.0));
        } else if (derivative == YES) {
            U = 2.0
              * std::complex<double>(std::cos(-PI / 3.0), std::sin(-PI / 3.0));
        };
    }
    // Wait W1 and W1'
    else if ((kind == WONE || kind == DWONE) && (scaling == WAIT)) {
        if (derivative == NO) {
            U = std::complex<double>(std::sqrt(3.0 * PI), -1.0 * std::sqrt(PI));
        } else if (derivative == YES) {
            U = std::complex<double>(
                -1.0 * std::sqrt(3.0 * PI), -1.0 * std::sqrt(PI)
            );
        };
    }
    // Wait W2 and W2'
    else if ((kind == WTWO || kind == DWTWO) && (scaling == WAIT)) {
        if (derivative == NO) {
            U = std::complex<double>(std::sqrt(3.0 * PI), std::sqrt(PI));
        } else if (derivative == YES) {
            U = std::complex<double>(-1.0 * std::sqrt(3.0 * PI), std::sqrt(PI));
        };
    };

    // Scale the return value
    Ai = Ai * U;

    return Ai;
}

}  // namespace LFMF
}  // namespace Propagation
}  // namespace ITS